import os, pathlib

ROOT = pathlib.Path(".").resolve()
DOCS = ROOT / "DocsSite"
SPECS = DOCS / "specs"
REF = DOCS / "ref"
SPECS.mkdir(parents=True, exist_ok=True)
REF.mkdir(parents=True, exist_ok=True)

include_ext = {
  ".md", ".txt",
  ".json", ".yml", ".yaml",
  ".cs", ".uxml", ".uss", ".asmdef",
  ".xml", ".shader", ".cginc", ".hlsl",
  ".toml", ".ini", ".cfg"
}

exclude_dir_names = {
  ".git", "Library", "Temp", "Obj", "Build", "Logs",
  "UserSettings", ".plastic", ".vscode",
  "DocsSite"  # ★必須：自己増殖防止
}

def should_skip_dir(p: pathlib.Path) -> bool:
  return any(part in exclude_dir_names for part in p.parts)

def lang_from_ext(ext: str) -> str:
  return {
    ".cs":"csharp", ".json":"json", ".yml":"yaml", ".yaml":"yaml",
    ".uxml":"xml", ".uss":"css", ".xml":"xml",
    ".shader":"c", ".hlsl":"hlsl", ".cginc":"c",
    ".toml":"toml", ".ini":"ini", ".cfg":"ini", ".md":"markdown", ".txt":"text"
  }.get(ext, "text")

def safe_read_text(fp: pathlib.Path) -> str | None:
  try:
    return fp.read_text(encoding="utf-8")
  except UnicodeDecodeError:
    try:
      return fp.read_text(encoding="utf-8-sig")
    except Exception:
      return None

# --- 1) Specs をコピー（Assets/Docs を正とする） ---
# rsyncの代わりにPythonで最小コピー（Actions上で確実に動く）
src_specs = ROOT / "Assets" / "Docs"
if src_specs.exists():
  for p in src_specs.rglob("*"):
    if p.is_dir(): 
      continue
    if p.suffix == ".meta":
      continue
    rel = p.relative_to(src_specs)
    dst = SPECS / rel
    dst.parent.mkdir(parents=True, exist_ok=True)
    dst.write_bytes(p.read_bytes())

# Specs index（入口）
(SPECS / "index.md").write_text(
  "# Specs\n\n"
  "このセクションは仕様書です。\n\n"
  "- Conventions: `Conventions/00_Index.md`\n",
  encoding="utf-8"
)

# --- 2) Ref を生成（テキストファイルを md ラップして検索可能に） ---
items: list[tuple[str, str]] = []  # (title, link)

count = 0
for dirpath, dirnames, filenames in os.walk(ROOT):
  dp = pathlib.Path(dirpath)
  if should_skip_dir(dp):
    dirnames[:] = []
    continue
  dirnames[:] = [d for d in dirnames if d not in exclude_dir_names]

  for fn in filenames:
    src = dp / fn
    if src.suffix == ".meta":
      continue
    ext = src.suffix.lower()
    if ext not in include_ext:
      continue

    text = safe_read_text(src)
    if text is None:
      continue

    rel = src.relative_to(ROOT)
    out_md = REF / (str(rel) + ".md")
    out_md.parent.mkdir(parents=True, exist_ok=True)

    lang = lang_from_ext(ext)
    text = text.replace("```", "``\\`")

    out_md.write_text(
      f"# {rel}\n\n"
      f"`{rel}`\n\n"
      f"```{lang}\n{text}\n```\n",
      encoding="utf-8"
    )

    # mkdocsのリンクは .md を外したパスで辿れる（use_directory_urls=true）
    link = str(out_md.relative_to(DOCS)).replace("\\", "/")
    items.append((str(rel), link))
    count += 1

# Ref index（探索の入口）
items.sort()
lines = ["# Reference\n", "自動生成された参照ページです（コード/JSON/設定など）。\n", "## Files\n"]
for title, link in items[:2000]:  # 多すぎると重いので上限（必要なら調整）
  lines.append(f"- [{title}]({link})")

(REF / "index.md").write_text("\n".join(lines) + "\n", encoding="utf-8")

# --- 3) Site Home ---
(DOCS / "index.md").write_text(
  "# 2024 EPIMETHEUS Docs\n\n"
  "- [Specs](specs/index.md)\n"
  "- [Reference](ref/index.md)\n",
  encoding="utf-8"
)

print(f"Generated reference pages: {count}")
